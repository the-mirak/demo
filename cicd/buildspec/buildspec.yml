version: 0.2

phases:
  install:
    runtime-versions:
      python: 3.9
    commands:
      - echo "Installing dependencies..."
      - curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.23.7/2022-06-29/bin/linux/amd64/kubectl
      - chmod +x kubectl
      - mv kubectl /usr/local/bin/
      - yum install -y jq gettext

  pre_build:
    commands:
      - echo "Setting up environment variables..."
      - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/streamlit-app
      - IMAGE_TAG=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - APP_NAME=streamlit-app
      - S3_BUCKET=kaniko-context-$AWS_ACCOUNT_ID-$AWS_REGION
      - IAM_ROLE_NAME="kaniko-ecr-push-role"
      - IAM_POLICY_NAME="kaniko-ecr-policy"
      - SERVICE_ACCOUNT="kaniko-builder"
      - CLUSTER_NAME=$EKS_CLUSTER_NAME
      - OIDC_PROVIDER_URL=$(aws eks describe-cluster --name "$CLUSTER_NAME" --query "cluster.identity.oidc.issuer" --output text)
      - OIDC_PROVIDER_ARN="arn:aws:iam::$AWS_ACCOUNT_ID:oidc-provider/${OIDC_PROVIDER_URL#https://}"

      - echo "Verifying IAM Role: $IAM_ROLE_NAME..."
      - |
        ROLE_EXISTS=$(aws iam get-role --role-name "$IAM_ROLE_NAME" --query "Role.RoleName" --output text 2>/dev/null || echo "None")
        if [ "$ROLE_EXISTS" == "None" ]; then
          echo "Creating IAM role: $IAM_ROLE_NAME"
          cat > /tmp/kaniko-trust-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": { "Federated": "$OIDC_PROVIDER_ARN" },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                  "StringEquals": { "${OIDC_PROVIDER_URL#https://}:sub": "system:serviceaccount:default:$SERVICE_ACCOUNT" }
                }
              }
            ]
          }
          EOF
          aws iam create-role --role-name "$IAM_ROLE_NAME" --assume-role-policy-document file:///tmp/kaniko-trust-policy.json
          echo "✅ IAM Role created: $IAM_ROLE_NAME"
        else
          echo "✅ IAM Role already exists"
        fi

      - echo "Verifying IAM Policy: $IAM_POLICY_NAME..."
      - |
        POLICY_EXISTS=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='$IAM_POLICY_NAME'].Arn" --output text)
        if [ -z "$POLICY_EXISTS" ] || [ "$POLICY_EXISTS" == "None" ]; then
          echo "Creating IAM policy: $IAM_POLICY_NAME"
          cat > /tmp/kaniko-ecr-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ecr:GetAuthorizationToken",
                  "ecr:BatchCheckLayerAvailability",
                  "ecr:BatchGetImage",
                  "ecr:CompleteLayerUpload",
                  "ecr:GetDownloadUrlForLayer",
                  "ecr:InitiateLayerUpload",
                  "ecr:PutImage",
                  "ecr:UploadLayerPart"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          aws iam create-policy --policy-name "$IAM_POLICY_NAME" --policy-document file:///tmp/kaniko-ecr-policy.json
          echo "✅ IAM Policy created: $IAM_POLICY_NAME"
        else
          echo "✅ IAM Policy already exists"
        fi

      - echo "Attaching IAM policy to role..."
      - aws iam attach-role-policy --role-name "$IAM_ROLE_NAME" --policy-arn "arn:aws:iam::$AWS_ACCOUNT_ID:policy/$IAM_POLICY_NAME"

      - echo "Verifying Kubernetes service account: $SERVICE_ACCOUNT..."
      - |
        kubectl annotate serviceaccount $SERVICE_ACCOUNT \
          -n default \
          eks.amazonaws.com/role-arn="arn:aws:iam::$AWS_ACCOUNT_ID:role/$IAM_ROLE_NAME" --overwrite || true
      - echo "✅ IRSA annotation applied: $IAM_ROLE_NAME"

      - echo "Creating S3 bucket for context if it doesn't exist..."
      - aws s3api create-bucket --bucket $S3_BUCKET --region $AWS_REGION --create-bucket-configuration LocationConstraint=$AWS_REGION || true
      - echo "Preparing application context..."
      - tar -czf /tmp/$APP_NAME.tar.gz -C app .
      - aws s3 cp /tmp/$APP_NAME.tar.gz s3://$S3_BUCKET/

  build:
    commands:
      - echo "Building the container image using Kaniko..."
      - kubectl delete pod ${APP_NAME}-kaniko-builder --ignore-not-found=true
      - envsubst < kubernetes/kaniko-pod.yaml > kubernetes/kaniko-pod-updated.yaml
      - kubectl apply -f kubernetes/kaniko-pod-updated.yaml
      - echo "Streaming Kaniko logs..."
      - kubectl logs -f ${APP_NAME}-kaniko-builder || true
      - echo "Waiting for Kaniko build to complete..."
      - |
        TIMEOUT=600
        START_TIME=$(date +%s)
        while true; do
          POD_STATUS=$(kubectl get pod ${APP_NAME}-kaniko-builder -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          CURRENT_TIME=$(date +%s)
          ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
          
          if [ "$POD_STATUS" == "Succeeded" ]; then
            echo "✅ Build succeeded!"
            break
          elif [ "$POD_STATUS" == "Failed" ]; then
            echo "❌ Build failed! Fetching logs..."
            kubectl logs ${APP_NAME}-kaniko-builder
            kubectl describe pod ${APP_NAME}-kaniko-builder
            exit 1
          elif [ $ELAPSED_TIME -gt $TIMEOUT ]; then
            echo "❌ Build timed out after $TIMEOUT seconds!"
            kubectl logs ${APP_NAME}-kaniko-builder
            kubectl describe pod ${APP_NAME}-kaniko-builder
            exit 1
          fi
          sleep 5
        done

  post_build:
    commands:
      - echo "Deploying to EKS..."
      - kubectl apply -f kubernetes/streamlit-deployment.yaml
      - kubectl rollout status deployment/streamlit-app --timeout=300s
      - kubectl delete pod ${APP_NAME}-kaniko-builder
      - echo "✅ Deployment completed successfully!"

artifacts:
  files:
    - kubernetes/streamlit-deployment-updated.yaml
    - kubernetes/kaniko-pod-updated.yaml
  discard-paths: no
